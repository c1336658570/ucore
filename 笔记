user/lib/syscall.c中的系统调用函数会调用syscall，syscall是一个宏定义在user/lib/syscall.h中。user/lib/syscall.h中有几个宏，来获取系统调用名。如果在user/lib/syscall.c中调用syscall传递四个参数，最后就会转为调用__ syscall3。如果调用user/lib/syscall.c中调用syscall传递三个参数，最后就会转为调用__syscall2。

__ syscall1，__ syscall2，__ syscall3等函数定义在user/lib/arch/riscv/syscall_arch.h中，在__ syscalln等函数中使用了ecall（异常的一种），会触发异常。

S态的CSR寄存器：

- scause: 它用于记录异常和中断的原因。它的最高位为1是中断，否则是异常。其低位决定具体的种类。
- sepc：处理完毕中断异常之后需要返回的PC值。
- stval: 产生异常的指令的地址。
- stvec：处理异常的函数的起始地址。
- sstatus：记录一些比较重要的状态，比如是否允许中断异常嵌套。

U态执行ecall指令的时候就产生了异常。此时CPU会处理上述的各个CSR寄存器，之后跳转至stvec所指向的地址，也就是我们的异常处理函数。os的这个函数的具体位置是在trap_init函数（os/trap.c）之中就指定了——是uservec函数。这个函数位于os/trampoline.S之中，是由汇编语言编写的。在uservec之中，os保存了U态执行流的各个寄存器的值。这些值的位置其实已经由trap.h中的trapframe结构体规定好了。

